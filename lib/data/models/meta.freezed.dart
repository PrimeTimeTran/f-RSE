// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'meta.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

Meta _$MetaFromJson(Map<String, dynamic> json) {
  return _Meta.fromJson(json);
}

/// @nodoc
mixin _$Meta {
  double get o => throw _privateConstructorUsedError;
  double get h => throw _privateConstructorUsedError;
  double get l => throw _privateConstructorUsedError;
  double get c => throw _privateConstructorUsedError;
  double get v => throw _privateConstructorUsedError;
  double get mc => throw _privateConstructorUsedError;
  double get dy => throw _privateConstructorUsedError;
  double get pe => throw _privateConstructorUsedError;
  double get av => throw _privateConstructorUsedError;
  double get awv => throw _privateConstructorUsedError;
  double get hiDay => throw _privateConstructorUsedError;
  double get loDay => throw _privateConstructorUsedError;
  double get hiYear => throw _privateConstructorUsedError;
  double get loYear => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MetaCopyWith<Meta> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MetaCopyWith<$Res> {
  factory $MetaCopyWith(Meta value, $Res Function(Meta) then) =
      _$MetaCopyWithImpl<$Res, Meta>;
  @useResult
  $Res call(
      {double o,
      double h,
      double l,
      double c,
      double v,
      double mc,
      double dy,
      double pe,
      double av,
      double awv,
      double hiDay,
      double loDay,
      double hiYear,
      double loYear});
}

/// @nodoc
class _$MetaCopyWithImpl<$Res, $Val extends Meta>
    implements $MetaCopyWith<$Res> {
  _$MetaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? o = null,
    Object? h = null,
    Object? l = null,
    Object? c = null,
    Object? v = null,
    Object? mc = null,
    Object? dy = null,
    Object? pe = null,
    Object? av = null,
    Object? awv = null,
    Object? hiDay = null,
    Object? loDay = null,
    Object? hiYear = null,
    Object? loYear = null,
  }) {
    return _then(_value.copyWith(
      o: null == o
          ? _value.o
          : o // ignore: cast_nullable_to_non_nullable
              as double,
      h: null == h
          ? _value.h
          : h // ignore: cast_nullable_to_non_nullable
              as double,
      l: null == l
          ? _value.l
          : l // ignore: cast_nullable_to_non_nullable
              as double,
      c: null == c
          ? _value.c
          : c // ignore: cast_nullable_to_non_nullable
              as double,
      v: null == v
          ? _value.v
          : v // ignore: cast_nullable_to_non_nullable
              as double,
      mc: null == mc
          ? _value.mc
          : mc // ignore: cast_nullable_to_non_nullable
              as double,
      dy: null == dy
          ? _value.dy
          : dy // ignore: cast_nullable_to_non_nullable
              as double,
      pe: null == pe
          ? _value.pe
          : pe // ignore: cast_nullable_to_non_nullable
              as double,
      av: null == av
          ? _value.av
          : av // ignore: cast_nullable_to_non_nullable
              as double,
      awv: null == awv
          ? _value.awv
          : awv // ignore: cast_nullable_to_non_nullable
              as double,
      hiDay: null == hiDay
          ? _value.hiDay
          : hiDay // ignore: cast_nullable_to_non_nullable
              as double,
      loDay: null == loDay
          ? _value.loDay
          : loDay // ignore: cast_nullable_to_non_nullable
              as double,
      hiYear: null == hiYear
          ? _value.hiYear
          : hiYear // ignore: cast_nullable_to_non_nullable
              as double,
      loYear: null == loYear
          ? _value.loYear
          : loYear // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MetaCopyWith<$Res> implements $MetaCopyWith<$Res> {
  factory _$$_MetaCopyWith(_$_Meta value, $Res Function(_$_Meta) then) =
      __$$_MetaCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double o,
      double h,
      double l,
      double c,
      double v,
      double mc,
      double dy,
      double pe,
      double av,
      double awv,
      double hiDay,
      double loDay,
      double hiYear,
      double loYear});
}

/// @nodoc
class __$$_MetaCopyWithImpl<$Res> extends _$MetaCopyWithImpl<$Res, _$_Meta>
    implements _$$_MetaCopyWith<$Res> {
  __$$_MetaCopyWithImpl(_$_Meta _value, $Res Function(_$_Meta) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? o = null,
    Object? h = null,
    Object? l = null,
    Object? c = null,
    Object? v = null,
    Object? mc = null,
    Object? dy = null,
    Object? pe = null,
    Object? av = null,
    Object? awv = null,
    Object? hiDay = null,
    Object? loDay = null,
    Object? hiYear = null,
    Object? loYear = null,
  }) {
    return _then(_$_Meta(
      o: null == o
          ? _value.o
          : o // ignore: cast_nullable_to_non_nullable
              as double,
      h: null == h
          ? _value.h
          : h // ignore: cast_nullable_to_non_nullable
              as double,
      l: null == l
          ? _value.l
          : l // ignore: cast_nullable_to_non_nullable
              as double,
      c: null == c
          ? _value.c
          : c // ignore: cast_nullable_to_non_nullable
              as double,
      v: null == v
          ? _value.v
          : v // ignore: cast_nullable_to_non_nullable
              as double,
      mc: null == mc
          ? _value.mc
          : mc // ignore: cast_nullable_to_non_nullable
              as double,
      dy: null == dy
          ? _value.dy
          : dy // ignore: cast_nullable_to_non_nullable
              as double,
      pe: null == pe
          ? _value.pe
          : pe // ignore: cast_nullable_to_non_nullable
              as double,
      av: null == av
          ? _value.av
          : av // ignore: cast_nullable_to_non_nullable
              as double,
      awv: null == awv
          ? _value.awv
          : awv // ignore: cast_nullable_to_non_nullable
              as double,
      hiDay: null == hiDay
          ? _value.hiDay
          : hiDay // ignore: cast_nullable_to_non_nullable
              as double,
      loDay: null == loDay
          ? _value.loDay
          : loDay // ignore: cast_nullable_to_non_nullable
              as double,
      hiYear: null == hiYear
          ? _value.hiYear
          : hiYear // ignore: cast_nullable_to_non_nullable
              as double,
      loYear: null == loYear
          ? _value.loYear
          : loYear // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Meta implements _Meta {
  const _$_Meta(
      {required this.o,
      required this.h,
      required this.l,
      required this.c,
      required this.v,
      required this.mc,
      required this.dy,
      required this.pe,
      required this.av,
      required this.awv,
      required this.hiDay,
      required this.loDay,
      required this.hiYear,
      required this.loYear});

  factory _$_Meta.fromJson(Map<String, dynamic> json) => _$$_MetaFromJson(json);

  @override
  final double o;
  @override
  final double h;
  @override
  final double l;
  @override
  final double c;
  @override
  final double v;
  @override
  final double mc;
  @override
  final double dy;
  @override
  final double pe;
  @override
  final double av;
  @override
  final double awv;
  @override
  final double hiDay;
  @override
  final double loDay;
  @override
  final double hiYear;
  @override
  final double loYear;

  @override
  String toString() {
    return 'Meta(o: $o, h: $h, l: $l, c: $c, v: $v, mc: $mc, dy: $dy, pe: $pe, av: $av, awv: $awv, hiDay: $hiDay, loDay: $loDay, hiYear: $hiYear, loYear: $loYear)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Meta &&
            (identical(other.o, o) || other.o == o) &&
            (identical(other.h, h) || other.h == h) &&
            (identical(other.l, l) || other.l == l) &&
            (identical(other.c, c) || other.c == c) &&
            (identical(other.v, v) || other.v == v) &&
            (identical(other.mc, mc) || other.mc == mc) &&
            (identical(other.dy, dy) || other.dy == dy) &&
            (identical(other.pe, pe) || other.pe == pe) &&
            (identical(other.av, av) || other.av == av) &&
            (identical(other.awv, awv) || other.awv == awv) &&
            (identical(other.hiDay, hiDay) || other.hiDay == hiDay) &&
            (identical(other.loDay, loDay) || other.loDay == loDay) &&
            (identical(other.hiYear, hiYear) || other.hiYear == hiYear) &&
            (identical(other.loYear, loYear) || other.loYear == loYear));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, o, h, l, c, v, mc, dy, pe, av,
      awv, hiDay, loDay, hiYear, loYear);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MetaCopyWith<_$_Meta> get copyWith =>
      __$$_MetaCopyWithImpl<_$_Meta>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_MetaToJson(
      this,
    );
  }
}

abstract class _Meta implements Meta {
  const factory _Meta(
      {required final double o,
      required final double h,
      required final double l,
      required final double c,
      required final double v,
      required final double mc,
      required final double dy,
      required final double pe,
      required final double av,
      required final double awv,
      required final double hiDay,
      required final double loDay,
      required final double hiYear,
      required final double loYear}) = _$_Meta;

  factory _Meta.fromJson(Map<String, dynamic> json) = _$_Meta.fromJson;

  @override
  double get o;
  @override
  double get h;
  @override
  double get l;
  @override
  double get c;
  @override
  double get v;
  @override
  double get mc;
  @override
  double get dy;
  @override
  double get pe;
  @override
  double get av;
  @override
  double get awv;
  @override
  double get hiDay;
  @override
  double get loDay;
  @override
  double get hiYear;
  @override
  double get loYear;
  @override
  @JsonKey(ignore: true)
  _$$_MetaCopyWith<_$_Meta> get copyWith => throw _privateConstructorUsedError;
}
